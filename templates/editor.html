<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="light dark" />
  <title>SmartSign ‚Äì PDF unterschreiben</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='editor.css') }}?v={{ cache_bust }}">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
</head>
<body>
  <header class="topbar">
    <h1>SmartSign</h1>
    <div class="spacer"></div>
    <button id="theme-toggle" class="btn ghost" aria-label="Theme umschalten">üåì</button>
  </header>

  <section id="toolbar" class="panel toolbar">
    <div class="tool-group">
      <label class="file">
        <input type="file" id="pdf-input" accept="application/pdf" />
        <span>PDF ausw√§hlen</span>
      </label>
      <button id="btn-upload" class="btn">Laden</button>
      <span id="meta" class="muted"></span>
    </div>

    <div class="tool-group">
      <button id="btn-prev" class="btn">‚Üê Zur√ºck</button>
      <button id="btn-next" class="btn">Weiter ‚Üí</button>
      <span class="muted">Seite <span id="page-num">1</span>/<span id="page-count">?</span></span>
    </div>

    <div class="tool-group nowrap">
      <label>Zoom
        <input id="zoom" type="range" min="50" max="200" value="100" />
      </label>
      <span id="zoom-val" class="muted">100%</span>
    </div>

    <div class="tool-group">
      <button id="btn-detect" class="btn secondary">Smart&nbsp;Detect</button>
      <label class="checkbox"><input type="checkbox" id="apply-all" /> auf alle Seiten</label>
    </div>
  </section>

  <section id="stage" class="stage">
    <div id="pdf-container" class="pdf">
      <canvas id="pdf-canvas"></canvas>
      <div id="overlay"></div>
    </div>
  </section>

  <section class="panel controls">
    <div class="tabs">
      <button class="tab-btn active" data-tab="draw">‚úçÔ∏è Zeichnen</button>
      <button class="tab-btn" data-tab="upload">üñºÔ∏è Bild hochladen</button>
    </div>

    <div id="tab-draw" class="tab active">
      <canvas id="sig-pad" width="420" height="130" class="sigpad"></canvas>
      <div class="actions">
        <button id="sig-clear" class="btn ghost">Leeren</button>
        <button id="sig-use" class="btn">Als Signatur verwenden</button>
      </div>
      <p class="muted">Tipp: Maus/Stift/Finger ‚Äì Linien werden gegl√§ttet.</p>
    </div>

    <div id="tab-upload" class="tab">
  <div class="file-row">
    <input type="file" id="sig-file" accept="image/png,image/jpeg,image/webp" />
    <button id="sig-use-file" type="button" class="btn">Bild als Signatur verwenden</button>
  </div>
    <div id="tab-upload1" class="tab1">
  <div class="file-upload">
    <input type="file"  id="sig-file1" accept="png/JPG/jpeg" />
    <button id="sigi" type="button" class="button1"> Test Bild hochladen</button>
       style="display:none;max-width:160px;margin-top:8px;border:1px solid var(--border);border-radius:6px;">
  <p class="muted">Tipp: PNG/JPG/WebP. HEIC/HEIF bitte vorher konvertieren.</p>
  </div>


    <div class="grid2">
      <label>Gr√∂√üe
        <input id="size" type="range" min="80" max="600" value="220" />
      </label>
      <div class="right-actions">
        <button id="btn-remove-sig" class="btn ghost">Signatur entfernen</button>
        <button id="btn-sign" class="btn primary">PDF signieren & herunterladen</button>
      </div>
    </div>
  </section>

  <script>
    // ---------------- Theme (light/dark) ----------------
    const root = document.documentElement;
    const themeKey = 'smartsign-theme';
    function applyTheme(t){ root.dataset.theme = t; }
    const stored = localStorage.getItem(themeKey);
    if (stored) { applyTheme(stored); }
    else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) { applyTheme('dark'); }
    document.getElementById('theme-toggle').addEventListener('click', ()=>{
      const next = (root.dataset.theme === 'dark') ? 'light' : 'dark';
      applyTheme(next); localStorage.setItem(themeKey, next);
    });

    // ---------------- State ----------------
    const uploadUrl = "{{ url_for('editor.upload_file') }}";
    const suggestUrl = "{{ url_for('editor.suggest_positions') }}";
    const signUrl = "{{ url_for('editor.sign_pdf') }}";

    let pdfToken = "";
    let pdfDoc = null;
    let pageNum = 1;
    let pageCount = 0;
    let scale = 1.0; // pdf.js viewport scale

    const canvas = document.getElementById('pdf-canvas');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const pdfContainer = document.getElementById('pdf-container');

    const placements = {}; // placements[page] = {nx, ny, nw, nh}

    // ---------------- PDF Rendering ----------------
    function fitScaleToWidth(page) {
      const containerW = pdfContainer.clientWidth || Math.min(900, window.innerWidth - 32);
      const viewport1 = page.getViewport({ scale: 1.0 });
      return Math.min(2.0, containerW / viewport1.width);
    }

    async function renderPage(num) {
      const page = await pdfDoc.getPage(num);
      const viewport = page.getViewport({ scale });
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);

      // overlay deckt den Canvas 1:1 ab
      overlay.style.width = canvas.width + 'px';
      overlay.style.height = canvas.height + 'px';
      overlay.style.left = '0px';
      overlay.style.top = '0px';

      await page.render({ canvasContext: ctx, viewport }).promise;
      document.getElementById('page-num').textContent = num;
      drawPlacementForPage(num);
    }

    function drawPlacementForPage(num) {
      overlay.innerHTML = '';
      const p = placements[num];
      if (p) {
        const { x, y, w, h } = fromNorm(p);
        addSigOverlay(x, y, w, h);
      }
    }

    function toNorm(x, y, w, h) { return { nx: x / canvas.width, ny: y / canvas.height, nw: w / canvas.width, nh: h / canvas.height }; }
    function fromNorm({ nx, ny, nw, nh }) { return { x: nx * canvas.width, y: ny * canvas.height, w: nw * canvas.width, h: nh * canvas.height }; }

    // ---------------- Upload PDF ----------------
    document.getElementById('btn-upload').addEventListener('click', async () => {
      const f = document.getElementById('pdf-input').files[0];
      if (!f) { alert('Bitte ein PDF ausw√§hlen.'); return; }
      const fd = new FormData(); fd.append('file', f);
      const r = await fetch(uploadUrl, { method: 'POST', body: fd });
      const data = await r.json();
      if (!r.ok) { alert(data.message || 'Upload fehlgeschlagen'); return; }
      pdfToken = data.pdf_token; const pdfURL = data.pdf_url;
      pdfjsLib.getDocument(pdfURL).promise.then(async (pdf) => {
        pdfDoc = pdf; pageCount = pdf.numPages;
        document.getElementById('page-count').textContent = pageCount;
        const page1 = await pdf.getPage(1);
        scale = fitScaleToWidth(page1);
        const zv = Math.round(scale * 100); document.getElementById('zoom').value = zv; document.getElementById('zoom-val').textContent = zv + '%';
        pageNum = 1; placements[1] = null;
        document.getElementById('meta').textContent = ` | Seiten: ${pageCount}`;
        renderPage(1);
      });
    });

    document.getElementById('btn-prev').addEventListener('click', () => { if (pdfDoc && pageNum > 1) { pageNum--; renderPage(pageNum); } });
    document.getElementById('btn-next').addEventListener('click', () => { if (pdfDoc && pageNum < pageCount) { pageNum++; renderPage(pageNum); } });

    document.getElementById('zoom').addEventListener('input', (e) => {
      if (!pdfDoc) return; scale = parseInt(e.target.value, 10) / 100;
      document.getElementById('zoom-val').textContent = Math.round(scale * 100) + '%';
      renderPage(pageNum);
    });

    // responsive: bei Resize neu einpassen
    let resizeTimer = null;
    window.addEventListener('resize', async () => {
      if (!pdfDoc) return;
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(async () => {
        const page = await pdfDoc.getPage(pageNum);
        scale = fitScaleToWidth(page);
        const zv = Math.round(scale * 100); document.getElementById('zoom').value = zv; document.getElementById('zoom-val').textContent = zv + '%';
        renderPage(pageNum);
      }, 150);
    });

// ---------------- Signature Source: draw/upload ----------------
const sigPad = document.getElementById('sig-pad');
const spCtx = sigPad.getContext('2d');
spCtx.lineWidth = 2; spCtx.lineCap = 'round';
let drawing = false;

// Mobile: Scrollen/Pinch w√§hrend des Zeichnens verhindern
function prevent(e){ e.preventDefault(); }
sigPad.addEventListener('pointerdown', (e)=>{ prevent(e); drawing = true; spCtx.beginPath(); spCtx.moveTo(e.offsetX, e.offsetY); sigPad.setPointerCapture(e.pointerId); }, {passive:false});
sigPad.addEventListener('pointermove', (e)=>{ if(!drawing) return; prevent(e); spCtx.lineTo(e.offsetX, e.offsetY); spCtx.stroke(); }, {passive:false});
sigPad.addEventListener('pointerup', ()=>{ drawing = false; }, {passive:false});
sigPad.addEventListener('pointerleave', ()=> drawing = false, {passive:false});
// iOS-Fallback
sigPad.addEventListener('touchstart', prevent, {passive:false});
sigPad.addEventListener('touchmove', prevent, {passive:false});

document.getElementById('sig-clear').addEventListener('click', ()=>{ spCtx.clearRect(0,0,sigPad.width, sigPad.height); });

let currentSigDataUrl = null;
// ‚Ä¶ (Rest deines Blocks unver√§ndert)


    function setSigFromDataURL(dataUrl) {
      currentSigDataUrl = dataUrl;
      if (pdfDoc) {
        const defaultW = parseInt(document.getElementById('size').value, 10);
        const defaultH = Math.round(defaultW * 0.35);
        const x = Math.max(12, canvas.width - defaultW - 12);
        const y = Math.max(12, canvas.height - defaultH - 12);
        addSigOverlay(x, y, defaultW, defaultH);
        placements[pageNum] = toNorm(x,y,defaultW,defaultH);
      }
    }

// --- robustes Bild-Upload-Setup ---
function fileToPngDataURL(file){
  return new Promise((resolve, reject)=>{
    const okMime = /^image\/(png|jpeg|webp)$/i.test(file.type || "");
    const okExt  = /\.(png|jpe?g|webp)$/i.test((file.name||"").toLowerCase());
    if (!okMime && !okExt) return reject(new Error("unsupported"));

    const img = new Image();
    img.onload = ()=>{
      const maxW = 1600;
      let w = img.naturalWidth || img.width, h = img.naturalHeight || img.height;
      if (w > maxW){ const r = maxW / w; w = maxW; h = Math.round(h * r); }
      const c = document.createElement("canvas");
      c.width = w; c.height = h;
      c.getContext("2d").drawImage(img, 0, 0, w, h);
      resolve(c.toDataURL("image/png"));
    };
    img.onerror = ()=> reject(new Error("decode-failed"));

    // Fallback: wenn URL.createObjectURL fehlt, FileReader verwenden
    if (window.URL && URL.createObjectURL) {
      img.src = URL.createObjectURL(file);
    } else {
      const fr = new FileReader();
      fr.onload = () => img.src = fr.result;
      fr.onerror = () => reject(fr.error || new Error("read-failed"));
      fr.readAsDataURL(file);
    }
  });
}

async function handleSignatureFile(file){
  try{
    const png = await fileToPngDataURL(file);
    const prev = document.getElementById("sig-preview");
    if (prev){ prev.src = png; prev.style.display = "block"; }
    setSigFromDataURL(png); // platziert sofort oder merkt sich die Signatur bis zum PDF
  }catch(e){
    alert("Dieses Bildformat wird nicht unterst√ºtzt. Bitte PNG / JPG / WebP verwenden.");
  }
}

(function wireUpload(){
  const input = document.getElementById("sig-file");
  const btn   = document.getElementById("sig-use-file");
  if (!input || !btn) return;

  // 1) Button klick: √∂ffnet Dateidialog, wenn noch keine Datei gew√§hlt ist
  btn.addEventListener("click", ()=>{
    const f = input.files && input.files[0];
    if (!f) { input.click(); return; }
    handleSignatureFile(f);
  });

  // 2) Nach Dateiauswahl sofort verarbeiten
  input.addEventListener("change", (e)=>{
    const f = e.target.files && e.target.files[0];
    if (f) handleSignatureFile(f);
  });

  // 3) Extra Safety: Event-Delegation (falls ein anderer Code sp√§ter ersetzt)
  document.addEventListener("click", (e)=>{
    if (e.target.closest && e.target.closest("#sig-use-file")) {
      const f = input.files && input.files[0];
      if (!f) { input.click(); return; }
      handleSignatureFile(f);
    }
  });
})();

    // ---------------- Overlay (drag & suggestions) ----------------
    function addSigOverlay(x, y, w, h) {
      overlay.innerHTML = '';
      const img = document.createElement('img');
      img.id = 'sigOverlay';
      img.src = currentSigDataUrl || sigPad.toDataURL('image/png');
      img.style.left = x + 'px'; img.style.top = y + 'px';
      img.style.width = w + 'px'; img.style.height = h + 'px';
      overlay.appendChild(img); enableDrag(img);
      return img;
    }

    function enableDrag(el) {
      let dragging = false; let startX=0, startY=0, startLeft=0, startTop=0;
      el.addEventListener('pointerdown', (e)=>{
        dragging = true; el.setPointerCapture(e.pointerId);
        startX = e.clientX; startY = e.clientY;
        startLeft = parseFloat(el.style.left); startTop = parseFloat(el.style.top);
      });
      el.addEventListener('pointermove', (e)=>{
        if(!dragging) return;
        const dx = e.clientX - startX; const dy = e.clientY - startY;
        let nx = Math.max(0, Math.min(startLeft + dx, canvas.width - el.clientWidth));
        let ny = Math.max(0, Math.min(startTop + dy, canvas.height - el.clientHeight));
        el.style.left = nx + 'px'; el.style.top = ny + 'px';
      });
      el.addEventListener('pointerup', ()=>{ dragging = false; savePlacementFromOverlay(); });
    }

    function savePlacementFromOverlay() {
      const el = document.getElementById('sigOverlay');
      if (!el) { placements[pageNum] = null; return; }
      const x = parseFloat(el.style.left), y = parseFloat(el.style.top);
      const w = el.clientWidth, h = el.clientHeight;
      placements[pageNum] = toNorm(x,y,w,h);
    }

    document.getElementById('size').addEventListener('input', (e)=>{
      const el = document.getElementById('sigOverlay'); if(!el) return;
      const w = parseInt(e.target.value, 10); const h = Math.round(w * 0.35);
      el.style.width = w + 'px'; el.style.height = h + 'px';
      savePlacementFromOverlay();
    });

    document.getElementById('btn-remove-sig').addEventListener('click', ()=>{ overlay.innerHTML = ''; placements[pageNum] = null; });

    // Smart Detect
    document.getElementById('btn-detect').addEventListener('click', async ()=>{
      if (!pdfToken) { alert('Bitte zuerst ein PDF laden.'); return; }
      const r = await fetch(suggestUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pdf_token: pdfToken })});
      const data = await r.json(); if (!r.ok) { alert(data.message || 'Detect fehlgeschlagen'); return; }
      drawSuggestions(data.suggestions || []);
    });

    function drawSuggestions(suggestions) {
      overlay.querySelectorAll('.suggestion').forEach(n=>n.remove());
      const current = suggestions.filter(s => s.page === pageNum);
      current.forEach(rect => {
        const { x, y, w, h } = fromNorm(rect);
        const box = document.createElement('div'); box.className = 'suggestion';
        box.style.left = x + 'px'; box.style.top = y + 'px';
        box.style.width = w + 'px'; box.style.height = h + 'px';
        box.title = 'Hier platzieren';
        box.addEventListener('click', ()=>{
          if (!currentSigDataUrl) { setSigFromDataURL(sigPad.toDataURL('image/png')); }
          addSigOverlay(x, y, w, h); placements[pageNum] = toNorm(x,y,w,h);
          overlay.querySelectorAll('.suggestion').forEach(n=>n.remove());
        });
        overlay.appendChild(box);
      });
    }

    // ---------------- Sign (POST to backend) ----------------
    document.getElementById('btn-sign').addEventListener('click', async ()=>{
      if (!pdfToken) { alert('Bitte zuerst ein PDF laden.'); return; }
      let sigDataUrl = currentSigDataUrl || sigPad.toDataURL('image/png');
      if (!sigDataUrl || sigDataUrl === 'data:,') { alert('Bitte zuerst eine Signatur zeichnen oder als Bild w√§hlen.'); return; }

      const useAll = document.getElementById('apply-all').checked;
      const payloadPlacements = [];
      if (useAll) {
        const p = placements[pageNum]; if (!p) { alert('Bitte zuerst die Signatur auf einer Seite platzieren.'); return; }
        for (let i = 1; i <= pageCount; i++) payloadPlacements.push({ page: i, nx: p.nx, ny: p.ny, nw: p.nw, nh: p.nh });
      } else {
        for (let i = 1; i <= pageCount; i++) { if (placements[i]) payloadPlacements.push({ page: i, ...placements[i] }); }
        if (payloadPlacements.length === 0) { alert('Bitte die Signatur mindestens auf einer Seite platzieren.'); return; }
      }

      const b64 = sigDataUrl.split(',')[1];
      const r = await fetch(signUrl, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ pdf_token: pdfToken, signature: b64, placements: payloadPlacements })});
      const data = await r.json(); if (!r.ok) { alert(data.message || 'Signieren fehlgeschlagen'); return; }
      window.open(data.signed_pdf_url, '_blank');
    });
  </script>
</body>
</html>


